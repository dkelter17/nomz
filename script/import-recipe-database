#!/usr/bin/env ruby
# frozen_string_literal: true

require 'csv'
require 'fileutils'
require 'json'
require 'jekyll'
require 'uri'

NOMZ_PROD_URL = "https://dkelter17.github.io/nomz"

tsv_db_file_path = ARGV.first
if tsv_db_file_path.nil? || tsv_db_file_path.empty? || !File.exist?(tsv_db_file_path)
  abort "script/import-recipe-database <tsv_file_path>"
end

output_json_file_path = "_data/recipe_database.json"

# {
#   "Recipe Name": "Minty Lamb Meatballs with Crispy Cabbage and Tahini Sauce",
#   "Source": "Cook This Book p. 97",
#   "Author": "Molly Baz",
#   "Category": "Dinner",
#   "Protein": "Lamb",
#   "Herbs": "Mint",
#   "Day of Week": "Weekday",
#   "Feeds": "4",
#   "Season": "Winter",
#   "Rating (3)": "2"
# },

def to_bool(input)
  input.to_s.downcase == "true"
end

def generate_source_slug(recipe_source:, recipe_author:, recipe_external_url:)
  # First, books.
  if !recipe_source.start_with?("http")
    return Jekyll::Utils.slugify(recipe_source.split(" p. ").first)
  end

  # Next, Drive URLs.
  if recipe_external_url.start_with?("https://drive.google.com")
    return Jekyll::Utils.slugify(recipe_author)
  end

  # Last, URLs.
  URI.parse(recipe_external_url).hostname.downcase
end

def fetch_content_for_recipe(site, collection_name, recipe)
  return nil if site.collections[collection_name].nil?

  recipe_doc = site.collections[collection_name].docs.find { |doc| doc.data["external_url"] == recipe.external_url }

  return nil if recipe_doc.nil?

  recipe_doc.content
end

# Import the TSV generated by Google Sheets.
rows = CSV.read(tsv_db_file_path, headers: true, col_sep: "\t", liberal_parsing: true)

class Recipe < Struct.new(
  :title,
  :source,
  :author,
  :protein,
  :vegetarian,
  :herbs,
  :day_of_week,
  :feeds,
  :season,
  :rating,
  :category,
  :url,
  :external_url,
  :drive_url,
  :tags)

  def self.create(
      title:,
      source:,
      author:,
      protein:,
      vegetarian:,
      herbs:,
      day_of_week:,
      feeds:,
      season:,
      rating:,
      category:,
      url:,
      external_url:,
      drive_url:,
      tags:)
    external_url = "" if external_url.nil? || external_url.empty? || !external_url.start_with?("http")
    url ||= File.join("", "notes", generate_source_slug(recipe_source: source, recipe_author: author, recipe_external_url: external_url), "#{Jekyll::Utils.slugify(title)}.html")
    new(
      title,
      source,
      author,
      protein,
      vegetarian,
      herbs,
      day_of_week,
      feeds,
      season,
      rating,
      category,
      url,
      external_url,
      drive_url,
      tags
    )
  end

  def to_stringified_keys_hash
    to_h.transform_keys(&:to_s)
  end

  def to_json(json_state = nil)
    to_h.to_json(json_state)
  end
end

recipe_list = rows.each_with_object([]) do |row, memo|
  next if row["Source"].nil?

  memo << Recipe.create(
    title: row["Recipe Name"],
    source: row["Source"],
    author: row["Author"],
    protein: row["Protein"].to_s.split(",").map(&:strip).map(&:downcase),
    vegetarian: to_bool(row["Vegetarian"]),
    herbs: row["Herbs"].to_s.split(",").map(&:strip).map(&:downcase),
    day_of_week: row["Day of Week"].to_s.downcase,
    feeds: row["Feeds"].to_i,
    season: row["Season"].to_s.downcase,
    rating: row["Rating (3)"].to_i,
    category: row["Category"].to_s.downcase,
    url: nil,
    external_url: row["Source"].to_s,
    drive_url: row["Drive URL"].to_s,
    tags: [
      *row["Protein"].to_s.split(",").map(&:strip).map(&:downcase),
      to_bool(row["Vegetarian"]) ? "vegetarian" : "",
      *row["Herbs"].to_s.split(",").map(&:strip).map(&:downcase).map{|s| s.split("/")},
      row["Season"].to_s.downcase,
      row["Day of Week"].to_s.downcase,
    ].reject(&:empty?).flatten || ["fallback"]
  )
end

site = Jekyll::Site.new(Jekyll.configuration)
site.read

# Write out a Jekyll collection called notes that contains each item in recipe_list.
collection_name = "notes"

recipe_list.each do |recipe|
  source_slug = generate_source_slug(
    recipe_source: recipe.source,
    recipe_author: recipe.author,
    recipe_external_url: recipe.external_url
  )
  recipe_notes_path = File.join("_#{collection_name}", source_slug, "#{Jekyll::Utils.slugify(recipe.title)}.md")
  if File.exist?(recipe_notes_path)
    Jekyll.logger.info "Notes: ", "[UPDATE] #{recipe_notes_path}"
  else
    Jekyll.logger.info "Notes: ", "[CREATE] #{recipe_notes_path}"
  end

  FileUtils.mkdir_p(File.dirname(recipe_notes_path))
  File.open(recipe_notes_path, "wb") do |f|
    YAML.dump(recipe.to_stringified_keys_hash.reject { |_,v| v.nil? || v.to_s.empty? }, f)
    f.puts("---")
    f.puts "\n"
    f.puts fetch_content_for_recipe(site, collection_name, recipe)
  end
end

site.collections["recipes"].docs.each do |doc|
  recipe_list << Recipe.create(
    title: doc.data.fetch("title"),
    source: NOMZ_PROD_URL + doc.url,
    author: doc.data["author"],
    protein: doc.data["protein"],
    vegetarian: doc.data["vegetarian"],
    herbs: doc.data["herbs"],
    day_of_week: doc.data["day_of_week"],
    feeds: doc.data["feeds"].to_i,
    season: doc.data["season"],
    rating: doc.data["rating"].to_i,
    category: doc.data["category"].to_s.downcase,
    url: doc.url,
    drive_url: (doc.data["drive-url"] || doc.data["drive_url"]).to_s,
    external_url: doc.data["external-url"].to_s,
    tags: doc.data["tags"],
  )
end

File.write(output_json_file_path, JSON.pretty_generate(recipe_list)+"\n")
