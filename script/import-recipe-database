#!/usr/bin/env ruby
# frozen_string_literal: true

require "csv"
require "fileutils"
require "json"
require "jekyll"
require "uri"

NOMZ_PROD_URL = "https://dkelter17.github.io/nomz"

SOURCE_SLUGS_TO_TITLES = {
  "cooking.nytimes.com" => "New York Times Cooking",
  "www.bonappetit.com" => "Bon AppÃ©tit",
  "www.mehreenkarim.com" => "Mehreen Karim",
  "mollybaz.com" => "Molly Baz Club",
  "chejorge.com" => "Che Jorge",
  "whatmollymade.com" => "What Molly Made",
  "justinesnacks.com" => "Justine Snacks"
}

tsv_db_file_path = ARGV.first
if tsv_db_file_path.nil? || tsv_db_file_path.empty? || !File.exist?(tsv_db_file_path)
  abort "script/import-recipe-database <tsv_file_path>"
end

output_json_file_path = "_data/recipe_database.json"

# {
#   "Recipe Name": "Minty Lamb Meatballs with Crispy Cabbage and Tahini Sauce",
#   "Source": "Cook This Book p. 97",
#   "Author": "Molly Baz",
#   "Category": "Dinner",
#   "Protein": "Lamb",
#   "Herbs": "Mint",
#   "Day of Week": "Weekday",
#   "Feeds": "4",
#   "Season": "Winter",
#   "Rating (3)": "2"
# },

def to_bool(input)
  input.to_s.downcase == "true"
end

def generate_source_slug(recipe_source:, recipe_author:, recipe_external_url:)
  # First, books.
  if !recipe_source.start_with?("http")
    return Jekyll::Utils.slugify(recipe_source.split(" p. ").first)
  end

  # Next, Drive URLs.
  if recipe_external_url.start_with?("https://drive.google.com")
    return Jekyll::Utils.slugify(recipe_author)
  end

  # Last, URLs.
  URI.parse(recipe_external_url).hostname.downcase
end

def titleize_slug(source_slug)
  if SOURCE_SLUGS_TO_TITLES.key?(source_slug)
    return SOURCE_SLUGS_TO_TITLES[source_slug]
  end

  Jekyll::Utils.titleize_slug(source_slug)
end

def fetch_content_for_recipe(site, collection_name, recipe)
  return nil if site.collections[collection_name].nil?

  recipe_doc = site.collections[collection_name].docs.find { |doc| doc.data["external_url"] == recipe.external_url }

  return nil if recipe_doc.nil?

  recipe_doc.content
end

# Import the TSV generated by Google Sheets.
rows = CSV.read(tsv_db_file_path, headers: true, col_sep: "\t", liberal_parsing: true)

class Recipe
  attr_accessor :title,
    :source,
    :author,
    :protein,
    :vegetarian,
    :herbs,
    :day_of_week,
    :feeds,
    :season,
    :rating,
    :category,
    :url,
    :external_url,
    :drive_url,
    :tags,
    :source_index_title

  def self.create(
    title:,
    source:,
    author:,
    protein:,
    vegetarian:,
    herbs:,
    day_of_week:,
    feeds:,
    season:,
    rating:,
    category:,
    url:,
    external_url:,
    drive_url:,
    tags:
  )
    external_url = "" if external_url.nil? || external_url.empty? || !external_url.start_with?("http")
    url ||= File.join("", "notes", generate_source_slug(recipe_source: source, recipe_author: author, recipe_external_url: external_url), "#{Jekyll::Utils.slugify(title)}.html")
    recipe = new
    recipe.title = title
    recipe.source = source
    recipe.author = author
    recipe.protein = protein
    recipe.vegetarian = vegetarian
    recipe.herbs = herbs
    recipe.day_of_week = day_of_week
    recipe.feeds = feeds
    recipe.season = season
    recipe.rating = rating
    recipe.category = category
    recipe.url = url
    recipe.external_url = external_url
    recipe.drive_url = drive_url
    recipe.tags = tags
    # recipe.freeze
    recipe
  end

  def to_h
    instance_variables.each_with_object({}) do |var, h|
      h[var.to_s.delete("@")] = instance_variable_get(var)
    end
  end

  def to_stringified_keys_hash
    to_h.transform_keys(&:to_s)
  end

  def to_json(json_state = nil)
    to_h.to_json(json_state)
  end
end

recipe_list = rows.each_with_object([]) do |row, memo|
  next if row["Source"].nil?

  memo << Recipe.create(
    title: row["Recipe Name"],
    source: row["Source"],
    author: row["Author"],
    protein: row["Protein"].to_s.split(",").map(&:strip).map(&:downcase),
    vegetarian: to_bool(row["Vegetarian"]),
    herbs: row["Herbs"].to_s.split(",").map(&:strip).map(&:downcase),
    day_of_week: row["Day of Week"].to_s.downcase,
    feeds: row["Feeds"].to_i,
    season: row["Season"].to_s.downcase,
    rating: row["Rating (3)"].to_i,
    category: row["Category"].to_s.downcase,
    url: nil,
    external_url: row["Source"].to_s,
    drive_url: row["Drive URL"].to_s,
    tags: [
      *row["Protein"].to_s.split(",").map(&:strip).map(&:downcase),
      to_bool(row["Vegetarian"]) ? "vegetarian" : "",
      *row["Herbs"].to_s.split(",").map(&:strip).map(&:downcase).map { |s| s.split("/") },
      row["Season"].to_s.downcase,
      row["Day of Week"].to_s.downcase
    ].reject(&:empty?).flatten || ["fallback"]
  )
end

site = Jekyll::Site.new(Jekyll.configuration)
site.read

# Write out a Jekyll collection called notes that contains each item in recipe_list.
collection_name = "notes"
# Write index pages manually that lists each recipe for that source.
source_index_pages = {}
sources_slugs_and_titles = {}

recipe_list.each do |recipe|
  source_slug = generate_source_slug(
    recipe_source: recipe.source,
    recipe_author: recipe.author,
    recipe_external_url: recipe.external_url
  )
  recipe_notes_path = File.join("_#{collection_name}", source_slug, "#{Jekyll::Utils.slugify(recipe.title)}.md")
  recipe.source_index_title = titleize_slug(source_slug)
  sources_slugs_and_titles[recipe.source_index_title] = File.join("", collection_name, source_slug, "")
  (source_index_pages[source_slug] ||= []).push({
    recipe_notes_path: recipe_notes_path,
    recipe: recipe
  })
  if File.exist?(recipe_notes_path)
    Jekyll.logger.info "Notes: ", "[UPDATE] #{recipe_notes_path}"
  else
    Jekyll.logger.info "Notes: ", "[CREATE] #{recipe_notes_path}"
  end

  FileUtils.mkdir_p(File.dirname(recipe_notes_path))
  File.open(recipe_notes_path, "wb") do |f|
    YAML.dump(recipe.to_stringified_keys_hash.reject { |_, v| v.nil? || v.to_s.empty? }, f)
    f.puts("---")
    f.puts "\n"
    f.puts fetch_content_for_recipe(site, collection_name, recipe)
  end
end

File.open("_data/notes_sources.json", "wb") do |f|
  f.puts JSON.pretty_generate(sources_slugs_and_titles)
end

# Write index pages and add links to their index pages to _data so they can
# be linked to on all the recipe & notes pages.
source_index_pages.each do |(source_slug, recipes)|
  index_page_path = File.join("_#{collection_name}", source_slug, "index.md")
  if File.exist?(index_page_path)
    Jekyll.logger.info "Notes: ", "[UPDATE] #{index_page_path}"
  else
    Jekyll.logger.info "Notes: ", "[CREATE] #{index_page_path}"
  end
  titleized_slug = titleize_slug(source_slug)
  File.open(index_page_path, "wb") do |f|
    f.puts(YAML.dump({
      "layout" => "notes_list",
      "title" => "Index of #{titleized_slug} recipes",
      "excerpt" => "A list of notes for recipes by/from #{titleized_slug}.",
      "notes" => recipes.map { |r| {"url" => r[:recipe].url} }
    }))
    f.puts "---"
  end
end

site.collections["recipes"].docs.each do |doc|
  recipe_list << Recipe.create(
    title: doc.data.fetch("title"),
    source: NOMZ_PROD_URL + doc.url,
    author: doc.data["author"],
    protein: doc.data["protein"],
    vegetarian: doc.data["vegetarian"],
    herbs: doc.data["herbs"],
    day_of_week: doc.data["day_of_week"],
    feeds: doc.data["feeds"].to_i,
    season: doc.data["season"],
    rating: doc.data["rating"].to_i,
    category: doc.data["category"].to_s.downcase,
    url: doc.url,
    drive_url: (doc.data["drive-url"] || doc.data["drive_url"]).to_s,
    external_url: doc.data["external_url"].to_s,
    tags: doc.data["tags"]
  )
end

File.write(output_json_file_path, JSON.pretty_generate(recipe_list) + "\n")
